#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define MAX_SIZE 100

// تعريف الهيكل لتخزين المصفوفة
typedef struct {
    int rows;
    int cols;
    int data[MAX_SIZE][MAX_SIZE];
} Matrix;

// تعريف الهيكل لتخزين النتائج المؤقتة في الحلقة
typedef struct {
    int row;
    int result[MAX_SIZE];
} Buffer;

// تعريف الهيكل الذي يحتوي على المتغيرات المشتركة بين المنتجين والمستهلكين
typedef struct {
    Matrix matrixB;
    Matrix matrixC;
    Matrix resultMatrix;
    Buffer buffer[MAX_SIZE];
    int bufferSize;
    int currentProducerIndex;
    int currentConsumerIndex;
    pthread_mutex_t mutex;
    pthread_cond_t producerCond;
    pthread_cond_t consumerCond;
} SharedData;

// دالة لإنشاء مصفوفة بحجم وقيم عشوائية
void generateRandomMatrix(Matrix *matrix, int rows, int cols) {
    matrix->rows = rows;
    matrix->cols = cols;

    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            matrix->data[i][j] = rand() % 10; // توليد قيم عشوائية بين 0 و 9
        }
    }
}

// دالة المنتج (الحاصل)
void *producer(void *arg) {
    SharedData *sharedData = (SharedData *)arg;

    while (1) {
        // قفل القفل لتجنب تداخل الإنتاج
        pthread_mutex_lock(&sharedData->mutex);

        // تحقق من أن هناك مزيد من الصفوف ليتم إنتاجها
        if (sharedData->currentProducerIndex < sharedData->matrixB.rows) {
            int rowIndex = sharedData->currentProducerIndex;
            // حساب الصف الحالي من المصفوفة الناتجة
            for (int j = 0; j < sharedData->matrixC.cols; ++j) {
                int result = 0;
                for (int k = 0; k < sharedData->matrixB.cols; ++k) {
                    result += sharedData->matrixB.data[rowIndex][k] * sharedData->matrixC.data[k][j];
                }
                sharedData->buffer[rowIndex].result[j] = result;
            }

            // زيادة مؤشر المنتج الحالي
            sharedData->currentProducerIndex++;

            // إشعار المستهلك بوجود بيانات جديدة
            pthread_cond_signal(&sharedData->consumerCond);
        } else {
            // قفل القفل
            pthread_mutex_unlock(&sharedData->mutex);
            break;
        }

        // قفل القفل
        pthread_mutex_unlock(&sharedData->mutex);
    }

    pthread_exit(NULL);
}

// دالة المستهلك
void *consumer(void *arg) {
    SharedData *sharedData = (SharedData *)arg;

    while (1) {
        // قفل القفل لتجنب تداخل الاستهلاك
        pthread_mutex_lock(&sharedData->mutex);

        // تحقق من أن هناك بيانات ليتم استهلاكها
        if (sharedData->currentConsumerIndex < sharedData->matrixB.rows) {
            int rowIndex = sharedData->currentConsumerIndex;
            // نسخ النتيجة إلى المصفوفة الناتجة
            for (int j = 0; j < sharedData->matrixC.cols; ++j) {
                sharedData->resultMatrix.data[rowIndex][j] = sharedData->buffer[rowIndex].result[j];
            }

            // زيادة مؤشر المستهلك الحالي
            sharedData->currentConsumerIndex++;

            // إشعار المنتج بوجود مكان فارغ في الحلقة
            pthread_cond_signal(&sharedData->producerCond);
        } else {
            // قفل القفل
            pthread_mutex_unlock(&sharedData->mutex);
            break;
        }

        // قفل القفل
        pthread_mutex_unlock(&sharedData->mutex);
    }

    pthread_exit(NULL);
}

int main() {
    // تهيئة بيانات المصفوفات والمتغيرات المشتركة
    SharedData sharedData;
    sharedData.currentProducerIndex = 0;
    sharedData.currentConsumerIndex = 0;
    sharedData.bufferSize = MAX_SIZE;

    // توليد المصفوفتين B و C بقيم عشوائية
    generateRandomMatrix(&sharedData.matrixB, 3, 4); // قم بتغيير الأرقام حسب حاجتك
    generateRandomMatrix(&sharedData.matrixC, 4, 2); // قم بتغيير الأرقام حسب حاجتك

    // إعداد المصفوفة الناتجة A
    sharedData.resultMatrix.rows = sharedData.matrixB.rows;
    sharedData.resultMatrix.cols = sharedData.matrixC.cols;

    // إعداد القفل والشروط
    pthread_mutex_init(&sharedData.mutex, NULL);
    pthread_cond_init(&sharedData.producerCond, NULL);
    pthread_cond_init(&sharedData.consumerCond, NULL);

    // إنشاء مجموعة من المنتجين والمستهلكين
    pthread_t producers[MAX_SIZE];
    pthread_t consumers[MAX_SIZE];

    // إطلاق المنتجين والمستهلكين
    for (int i = 0; i < sharedData.bufferSize; ++i) {
        pthread_create(&producers
        [i], NULL, producer, (void *)&sharedData);
        pthread_create(&consumers[i], NULL, consumer, (void *)&sharedData);
    }

    // الانضمام إلى المنتجين والمستهلكين بانتظام
    for (int i = 0; i < sharedData.bufferSize; ++i) {
        pthread_join(producers[i], NULL);
        pthread_join(consumers[i], NULL);
    }

    // طباعة المصفوفة B
    printf("Matrix B:\n");
    for (int i = 0; i < sharedData.matrixB.rows; ++i) {
        for (int j = 0; j < sharedData.matrixB.cols; ++j) {
            printf("%d ", sharedData.matrixB.data[i][j]);
        }
        printf("\n");
    }

    printf("\n");

    // طباعة المصفوفة C
    printf("Matrix C:\n");
    for (int i = 0; i < sharedData.matrixC.rows; ++i) {
        for (int j = 0; j < sharedData.matrixC.cols; ++j) {
            printf("%d ", sharedData.matrixC.data[i][j]);
        }
        printf("\n");
    }

    printf("\n");

    // طباعة المصفوفة الناتجة A
    printf("Result Matrix A = B * C:\n");
    for (int i = 0; i < sharedData.resultMatrix.rows; ++i) {
        for (int j = 0; j < sharedData.resultMatrix.cols; ++j) {
            printf("%d ", sharedData.resultMatrix.data[i][j]);
        }
        printf("\n");
    }

    // تحرير الموارد
    pthread_mutex_destroy(&sharedData.mutex);
    pthread_cond_destroy(&sharedData.producerCond);
    pthread_cond_destroy(&sharedData.consumerCond);

    return 0;
}
